import Vuex from 'vuex';
import { mount, createLocalVue } from '@vue/test-utils';

import { GlAvatar, GlLink } from '@gitlab/ui';

import { SEVERITY_GROUP_TYPES } from 'ee/security_dashboard/store/modules/vulnerable_projects/constants';

import { Accordion, AccordionItem } from 'ee/vue_shared/components/accordion';
import VulnerabilitySeverity from 'ee/security_dashboard/components/vulnerability_severity.vue';

const localVue = createLocalVue();
localVue.use(Vuex);

describe('Vulnerability Severity component', () => {
  let actions;
  let getters;
  let store;
  let propsData;
  let wrapper;

  const getMockProject = () => ({
    path: '/foo/bar',
    name: 'baz',
    mostSevere: { name: 'qux', count: 10 },
  });

  const factory = () => {
    const state = {
      isLoading: false,
      projects: [],
    };

    propsData = {
      endpoint: 'http://foo.com',
    };

    actions = {
      fetchProjects: jest.fn(),
    };

    getters = {
      severityGroups: ({ projects = [] }) => ({
        A: { projects },
        B: { projects },
        D: { projects },
        E: { projects },
        F: { projects },
      }),
    };

    store = new Vuex.Store({
      modules: {
        vulnerableProjects: {
          namespaced: true,
          actions,
          getters,
          state,
        },
      },
    });

    wrapper = mount(VulnerabilitySeverity, {
      localVue,
      store,
      sync: false,
      propsData,
    });
  };

  const accordion = () => wrapper.find(Accordion);
  const accordionItems = () => wrapper.findAll(AccordionItem);
  const firstAccordionItem = () => accordionItems().at(0);
  const hasAccordionItemForEachSeverityLevel = () =>
    expect(accordionItems().length).toBe(Object.keys(SEVERITY_GROUP_TYPES).length);

  const hasEachAccordionItemDisabled = () =>
    accordionItems().wrappers.every(item => item.props('disabled'));

  beforeEach(factory);

  afterEach(() => {
    wrapper.destroy();
    jest.restoreAllMocks();
  });

  describe('when being created', () => {
    it('dispatches the "fetchProjects" action with the given endpoint as an argument', () => {
      expect(actions.fetchProjects).toHaveBeenCalledTimes(1);
      expect(actions.fetchProjects.mock.calls[0][1]).toBe(propsData.endpoint);
    });
  });

  describe('while the data is being loaded', () => {
    beforeEach(() => {
      store.state.vulnerableProjects.isLoading = true;
      return wrapper.vm.$nextTick();
    });

    it('passes the isLoading state to the accordion as a prop', () => {
      expect(firstAccordionItem().props('isLoading')).toBe(true);
    });

    it('contains an accordion item for each of the severity levels', () => {
      hasAccordionItemForEachSeverityLevel();
    });
  });

  describe('when the data has loaded', () => {
    it('contains an accordion', () => {
      expect(accordion().exists()).toBe(true);
    });

    it('contains an accordion item for each of the severity levels', () => {
      hasAccordionItemForEachSeverityLevel();
    });

    it('sets accordion items to be disabled if its given severity level has no projects', () => {
      store.state.vulnerableProjects.projects = [];

      return wrapper.vm.$nextTick().then(() => {
        expect(hasEachAccordionItemDisabled()).toBe(true);
      });
    });

    it('does not set accordion items to be disabled if its given severity level has projects', () => {
      store.state.vulnerableProjects.projects = [getMockProject()];

      return wrapper.vm.$nextTick().then(() => {
        expect(hasEachAccordionItemDisabled()).toBe(false);
      });
    });

    it('contains an avatar that shows the severity group', () => {
      expect(
        firstAccordionItem()
          .find(GlAvatar)
          .exists(),
      ).toBe(true);
    });

    it('links to a given project', () => {
      const mockProject = getMockProject();
      store.state.vulnerableProjects.projects = [mockProject];

      return wrapper.vm.$nextTick().then(() => {
        expect(
          firstAccordionItem()
            .find(GlLink)
            .attributes('href'),
        ).toContain(mockProject.path);

        expect(firstAccordionItem().text()).toContain(mockProject.name);
      });
    });

    it('shows a count of the given most severe vulnerabilities', () => {
      const project = { mostSevere: { name: 'critical', count: 10 } };
      store.state.vulnerableProjects.projects = [project];

      return wrapper.vm.$nextTick().then(() => {
        expect(wrapper.find({ ref: 'mostSevereCount' }).text()).toBe('critical 10');
      });
    });
  });
});
