import Vuex from 'vuex';
import { shallowMount, createLocalVue } from '@vue/test-utils';

import { Accordion, AccordionItem } from 'ee/vue_shared/components/accordion';

import VulnerabilitySeverity from 'ee/security_dashboard/components/vulnerability_severity.vue';

const localVue = createLocalVue();
localVue.use(Vuex);

describe('Vulnerability Severity component', () => {
  let actions;
  let getters;
  let store;
  let propsData;
  let wrapper;

  const factory = () => {
    const state = {
      isLoading: false,
      projects: [],
    };

    propsData = {
      endpoint: 'http://foo.com',
    };

    actions = {
      fetchProjects: jest.fn(),
    };

    getters = {
      severityGroups: ({ projects = [] }) => ({
        A: { projects },
        B: { projects },
        D: { projects },
        E: { projects },
        F: { projects },
      }),
    };

    store = new Vuex.Store({
      modules: {
        vulnerableProjects: {
          namespaced: true,
          actions,
          getters,
          state,
        },
      },
    });

    wrapper = shallowMount(VulnerabilitySeverity, {
      localVue,
      store,
      sync: false,
      propsData,
    });
  };

  const accordion = () => wrapper.find(Accordion);
  const accordionItems = () => wrapper.findAll(AccordionItem);
  const hasAccordionItemForEachSeverityLevel = () =>
    // @TODO - find better way
    expect(accordionItems().length).toBe(5);

  const hasEachAccordionItemDisabled = () =>
    accordionItems().wrappers.every(item => item.props('disabled'));

  beforeEach(factory);

  afterEach(() => {
    wrapper.destroy();
    jest.restoreAllMocks();
  });

  describe('when being created', () => {
    it('dispatches the "fetchProjects" action with the given endpoint as an argument', () => {
      expect(actions.fetchProjects).toHaveBeenCalledTimes(1);
      expect(actions.fetchProjects.mock.calls[0][1]).toBe(propsData.endpoint);
    });
  });

  describe('while the data is being loaded', () => {
    beforeEach(() => {
      store.state.vulnerableProjects.isLoading = true;
      return wrapper.vm.$nextTick();
    });

    it('passes the isLoading state to the accordion as a prop', () => {
      expect(accordion().props('isLoading')).toBe(true);
    });

    it('contains an accordion item for each of the severity levels', () => {
      hasAccordionItemForEachSeverityLevel();
    });
  });

  describe('when the data has loaded', () => {
    it('contains an accordion item for each of the severity levels', () => {
      hasAccordionItemForEachSeverityLevel();
    });

    it('sets accordion items to be disabled if its given severity level has no projects', () => {
      store.state.vulnerableProjects.projects = [];

      return wrapper.vm.$nextTick().then(() => {
        expect(hasEachAccordionItemDisabled()).toBe(true);
      });
    });

    it('does not set accordion items to be disabled if its given severity level has projects', () => {
      store.state.vulnerableProjects.projects = [{}];

      return wrapper.vm.$nextTick().then(() => {
        expect(hasEachAccordionItemDisabled()).toBe(false);
      });
    });

    it('contains a list of the given project within every accordion item', () => {
      const project = { path: '/foo/bar', name: 'baz' };
      store.state.vulnerableProjects.projects = [project];

      return wrapper.vm.$nextTick().then(() => {
        expect(
          accordionItems()
            .at(0)
            .find('a')
            .attributes('href'),
        ).toContain(project.path);

        expect(
          accordionItems()
            .at(0)
            .text(),
        ).toContain(project.name);
      });
    });

    it.todo('contains a count of the most critical vulnerabilities for each project');
  });
});
